트리 이론
=

## 트리의 개념
__계층적 구조를 갖는 데이터를 표현하기 위한 자료 구조__   
* 노드(Node) : 데이터를 표현
* 간선(Edge) : 노드의 계층 구조를 표현하기 위해 사용

## 트리의 예시
<img src="D:\Git Fork\Learn_Unity\Algorithm\Algorithm\Theory\Image\Department.jpg" width="500" height="300">   

## 트리 관련 용어
* 부모(Parent) 노드 : 간선으로 이어진 노드 중 위에 위치한 노드. 부모가 없을 수 있어도 두개 이상이 될 수는 없다.
* 자식(Child) 노드 : 간선으로 이어진 노드 중 아래에 위치한 노드. 부모 노드는 둘 이상의 자식 노드를 가질 수 있다.
* 형제(Sibling) 노드 : 같은 부모 노드를 가진 동일한 계층의 노드. (같은 레벨(Level)에 위치한 노드)
* 선조(Ancestor) : 부모 노드의 간선을 타고 올라가서 윗 계층에 있는 노드.
* 자손(Descendant) : 자식 노드의 간선을 타고 내려가서 아래 계층에 있는 노드
* 루트(Root) : 부모 노드가 없는 가장 윗 계층의 노드
* 잎(Leaf) : 자식이 없는 가장 아래 계층의 노드
* 노드의 깊이(Depth) : 노드를 기준으로 몇 계층을 내려가는가/올라가는가. 
  * 예시 그림 : 기준 R1 개발실 -> 0. 디자인팀/ 프로그래밍팀/ 아트팀 -> 1. 전투/경제 등 -> 2.
* 트리의 높이(Height) : 트리가 가질 수 있는 최대 깊이.
* 트리의 재귀적 속성 및 서브트리(Subtree) : 자신의 자식을 루트로 하는 트리. 트리 연산을 할 때는 재귀함수가 유용하게 사용된다.


이진 트리
-

### 이진 트리의 개념
각 노드가 최대 두 개의 자식 노드를 가지는 트리

### 이진 검색 트리의 특징
* 왼쪽을 타고 가면 현재값보다 작다
* 오른쪽을 타고 가면 현재 값보다 크다   
-> 데이터를 빠르게 찾을 수 있다

#### 이진 검색 트리의 문제
그냥 무식하게 추가하면 한쪽으로 기울어져서 균형이 깨진다   
-> 트리 재배치를 통해 균형을 유지하는 것이 과제(AVL, Red-Black)


힙 트리
-

### 힙 트리의 특징
힙 트리 1법칙 : __부모 노드가 가진 값은 항상 자식 노드가 가진 값보다 크다.__   
힙 트리 2법칙 : 노드의 개수를 알면 트리 구조는 무조건 확정할 수 있다.

### 힙 트리의 구조
1. 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차 있다
2. 마지막 레벨에 노드가 있을 때는, 항상 왼쪽부터 순서대로 채워야 한다

### 힙 트리 구현
2법칙에 따라 배열을 이용해서 힙 구조를 바로 표현할 수 있다.
1. i번 노드의 왼쪽 자식은 (2*i)+1번
2. i번 노드의 오른쪽 자식은 (2*i)+2번
3. i번 노드의 부모는 (i-1)/2번

#### 새로운 값 추가
1. 2법칙에 따라 우선 트리 구조부터 맞춰 본다
2. 1법칙에 따라 부모 노드의 값과 비교하며, 값이 더 크면 자리를 변경한다

#### 최대값 꺼내기
힙 트리 특성상 최대값은 루트 노드에 있다.
1. 최대값을 먼저 제거한다.
2. 제일 마지막에 위치한 데이터를 루트로 옮긴다.
3. 1법칙에 따라 자식 노드 중 큰 값과 값을 비교하며, 값이 더 작으면 자리를 변경한다